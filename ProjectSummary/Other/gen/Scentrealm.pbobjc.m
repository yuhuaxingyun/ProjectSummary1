// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Scentrealm.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Scentrealm.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - ScentrealmRoot

@implementation ScentrealmRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ScentrealmRoot_FileDescriptor

static GPBFileDescriptor *ScentrealmRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"com.scentrealm"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum SrCmdId

GPBEnumDescriptor *SrCmdId_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SciCmdNone\000SciReqSleep\000SciReqWakeup\000SciR"
        "eqUsedseconds\000SciReqPlaysmell\000SciReqGetd"
        "evattr\000SciReqSetdevattr\000SciReqDeviceMode"
        "l\000SciReqStopPlay\000SciReqRemoveTask\000SciReq"
        "SetControlAttr\000SciReqDevWifiList\000SciReqS"
        "etDevWifi\000SciReqWifiConnReport\000SciReqNet"
        "ConnReport\000SciRespSleep\000SciRespWakeup\000Sc"
        "iRespUsedseconds\000SciRespPlaysmell\000SciRes"
        "pGetdevattr\000SciRespSetdevattr\000SciRespDev"
        "iceModel\000SciRespStopPlay\000SciRespRemoveTa"
        "sk\000SciRespSetControlAttr\000SciRespDevWifiL"
        "ist\000SciRespSetDevWifi\000SciRespWifiConnRep"
        "ort\000SciRespNetConnReport\000SciPush\000";
    static const int32_t values[] = {
        SrCmdId_SciCmdNone,
        SrCmdId_SciReqSleep,
        SrCmdId_SciReqWakeup,
        SrCmdId_SciReqUsedseconds,
        SrCmdId_SciReqPlaysmell,
        SrCmdId_SciReqGetdevattr,
        SrCmdId_SciReqSetdevattr,
        SrCmdId_SciReqDeviceModel,
        SrCmdId_SciReqStopPlay,
        SrCmdId_SciReqRemoveTask,
        SrCmdId_SciReqSetControlAttr,
        SrCmdId_SciReqDevWifiList,
        SrCmdId_SciReqSetDevWifi,
        SrCmdId_SciReqWifiConnReport,
        SrCmdId_SciReqNetConnReport,
        SrCmdId_SciRespSleep,
        SrCmdId_SciRespWakeup,
        SrCmdId_SciRespUsedseconds,
        SrCmdId_SciRespPlaysmell,
        SrCmdId_SciRespGetdevattr,
        SrCmdId_SciRespSetdevattr,
        SrCmdId_SciRespDeviceModel,
        SrCmdId_SciRespStopPlay,
        SrCmdId_SciRespRemoveTask,
        SrCmdId_SciRespSetControlAttr,
        SrCmdId_SciRespDevWifiList,
        SrCmdId_SciRespSetDevWifi,
        SrCmdId_SciRespWifiConnReport,
        SrCmdId_SciRespNetConnReport,
        SrCmdId_SciPush,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SrCmdId)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SrCmdId_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SrCmdId_IsValidValue(int32_t value__) {
  switch (value__) {
    case SrCmdId_SciCmdNone:
    case SrCmdId_SciReqSleep:
    case SrCmdId_SciReqWakeup:
    case SrCmdId_SciReqUsedseconds:
    case SrCmdId_SciReqPlaysmell:
    case SrCmdId_SciReqGetdevattr:
    case SrCmdId_SciReqSetdevattr:
    case SrCmdId_SciReqDeviceModel:
    case SrCmdId_SciReqStopPlay:
    case SrCmdId_SciReqRemoveTask:
    case SrCmdId_SciReqSetControlAttr:
    case SrCmdId_SciReqDevWifiList:
    case SrCmdId_SciReqSetDevWifi:
    case SrCmdId_SciReqWifiConnReport:
    case SrCmdId_SciReqNetConnReport:
    case SrCmdId_SciRespSleep:
    case SrCmdId_SciRespWakeup:
    case SrCmdId_SciRespUsedseconds:
    case SrCmdId_SciRespPlaysmell:
    case SrCmdId_SciRespGetdevattr:
    case SrCmdId_SciRespSetdevattr:
    case SrCmdId_SciRespDeviceModel:
    case SrCmdId_SciRespStopPlay:
    case SrCmdId_SciRespRemoveTask:
    case SrCmdId_SciRespSetControlAttr:
    case SrCmdId_SciRespDevWifiList:
    case SrCmdId_SciRespSetDevWifi:
    case SrCmdId_SciRespWifiConnReport:
    case SrCmdId_SciRespNetConnReport:
    case SrCmdId_SciPush:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SrErrorCode

GPBEnumDescriptor *SrErrorCode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SecNone\000SecSuccess\000SecAccept\000SecError\000Se"
        "cReject\000";
    static const int32_t values[] = {
        SrErrorCode_SecNone,
        SrErrorCode_SecSuccess,
        SrErrorCode_SecAccept,
        SrErrorCode_SecError,
        SrErrorCode_SecReject,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SrErrorCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SrErrorCode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SrErrorCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case SrErrorCode_SecNone:
    case SrErrorCode_SecSuccess:
    case SrErrorCode_SecAccept:
    case SrErrorCode_SecError:
    case SrErrorCode_SecReject:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SrTimeMode

GPBEnumDescriptor *SrTimeMode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "StmNone\000StmRelative\000StmAbsolute\000StmDayti"
        "me\000StmWeekday\000StmMonthday\000StmMonth\000StmYe"
        "ar\000";
    static const int32_t values[] = {
        SrTimeMode_StmNone,
        SrTimeMode_StmRelative,
        SrTimeMode_StmAbsolute,
        SrTimeMode_StmDaytime,
        SrTimeMode_StmWeekday,
        SrTimeMode_StmMonthday,
        SrTimeMode_StmMonth,
        SrTimeMode_StmYear,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SrTimeMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SrTimeMode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SrTimeMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case SrTimeMode_StmNone:
    case SrTimeMode_StmRelative:
    case SrTimeMode_StmAbsolute:
    case SrTimeMode_StmDaytime:
    case SrTimeMode_StmWeekday:
    case SrTimeMode_StmMonthday:
    case SrTimeMode_StmMonth:
    case SrTimeMode_StmYear:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SrCycleMode

GPBEnumDescriptor *SrCycleMode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ScmNone\000ScmCycleNo\000ScmCycleYes\000ScmCycleI"
        "nfinite\000";
    static const int32_t values[] = {
        SrCycleMode_ScmNone,
        SrCycleMode_ScmCycleNo,
        SrCycleMode_ScmCycleYes,
        SrCycleMode_ScmCycleInfinite,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SrCycleMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SrCycleMode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SrCycleMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case SrCycleMode_ScmNone:
    case SrCycleMode_ScmCycleNo:
    case SrCycleMode_ScmCycleYes:
    case SrCycleMode_ScmCycleInfinite:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SrRemoveTaskMode

GPBEnumDescriptor *SrRemoveTaskMode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SrtNone\000SrtStopCancel\000SrtStopNotcancel\000S"
        "rtNotstopCancel\000";
    static const int32_t values[] = {
        SrRemoveTaskMode_SrtNone,
        SrRemoveTaskMode_SrtStopCancel,
        SrRemoveTaskMode_SrtStopNotcancel,
        SrRemoveTaskMode_SrtNotstopCancel,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SrRemoveTaskMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SrRemoveTaskMode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SrRemoveTaskMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case SrRemoveTaskMode_SrtNone:
    case SrRemoveTaskMode_SrtStopCancel:
    case SrRemoveTaskMode_SrtStopNotcancel:
    case SrRemoveTaskMode_SrtNotstopCancel:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SrDevAttrType

GPBEnumDescriptor *SrDevAttrType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SdstNone\000SdstDeviceid\000SdstDevicename\000Sds"
        "tDevicetype\000SdstMac\000SdstWifissid\000SdstWif"
        "ipwd\000SdstNetconnectstate\000SdstBleconnects"
        "tate\000SdstLogstate\000SdstDatetime\000SdstUptim"
        "e\000SdstDowntime\000";
    static const int32_t values[] = {
        SrDevAttrType_SdstNone,
        SrDevAttrType_SdstDeviceid,
        SrDevAttrType_SdstDevicename,
        SrDevAttrType_SdstDevicetype,
        SrDevAttrType_SdstMac,
        SrDevAttrType_SdstWifissid,
        SrDevAttrType_SdstWifipwd,
        SrDevAttrType_SdstNetconnectstate,
        SrDevAttrType_SdstBleconnectstate,
        SrDevAttrType_SdstLogstate,
        SrDevAttrType_SdstDatetime,
        SrDevAttrType_SdstUptime,
        SrDevAttrType_SdstDowntime,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SrDevAttrType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SrDevAttrType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SrDevAttrType_IsValidValue(int32_t value__) {
  switch (value__) {
    case SrDevAttrType_SdstNone:
    case SrDevAttrType_SdstDeviceid:
    case SrDevAttrType_SdstDevicename:
    case SrDevAttrType_SdstDevicetype:
    case SrDevAttrType_SdstMac:
    case SrDevAttrType_SdstWifissid:
    case SrDevAttrType_SdstWifipwd:
    case SrDevAttrType_SdstNetconnectstate:
    case SrDevAttrType_SdstBleconnectstate:
    case SrDevAttrType_SdstLogstate:
    case SrDevAttrType_SdstDatetime:
    case SrDevAttrType_SdstUptime:
    case SrDevAttrType_SdstDowntime:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SrSwitchStatus

GPBEnumDescriptor *SrSwitchStatus_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "SssNone\000SssOn\000SssOff\000";
    static const int32_t values[] = {
        SrSwitchStatus_SssNone,
        SrSwitchStatus_SssOn,
        SrSwitchStatus_SssOff,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SrSwitchStatus)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SrSwitchStatus_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SrSwitchStatus_IsValidValue(int32_t value__) {
  switch (value__) {
    case SrSwitchStatus_SssNone:
    case SrSwitchStatus_SssOn:
    case SrSwitchStatus_SssOff:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BaseResponse

@implementation BaseResponse

@dynamic code;
@dynamic msg;

typedef struct BaseResponse__storage_ {
  uint32_t _has_storage_[1];
  SrErrorCode code;
  NSString *msg;
} BaseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = SrErrorCode_EnumDescriptor,
        .number = BaseResponse_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseResponse__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = BaseResponse_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseResponse__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseResponse class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BaseResponse_Code_RawValue(BaseResponse *message) {
  GPBDescriptor *descriptor = [BaseResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BaseResponse_FieldNumber_Code];
  return GPBGetMessageInt32Field(message, field);
}

void SetBaseResponse_Code_RawValue(BaseResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [BaseResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BaseResponse_FieldNumber_Code];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - BaseRequest

@implementation BaseRequest


typedef struct BaseRequest__storage_ {
  uint32_t _has_storage_[1];
} BaseRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseRequest class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(BaseRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UsedTimeResponse

@implementation UsedTimeResponse

@dynamic hasResponse, response;
@dynamic usedTimeArray, usedTimeArray_Count;

typedef struct UsedTimeResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *response;
  NSMutableArray *usedTimeArray;
} UsedTimeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "response",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = UsedTimeResponse_FieldNumber_Response,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UsedTimeResponse__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "usedTimeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UsedTimeResponse_UsedTime),
        .number = UsedTimeResponse_FieldNumber_UsedTimeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UsedTimeResponse__storage_, usedTimeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UsedTimeResponse class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UsedTimeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UsedTimeResponse_UsedTime

@implementation UsedTimeResponse_UsedTime

@dynamic bottle;
@dynamic time;

typedef struct UsedTimeResponse_UsedTime__storage_ {
  uint32_t _has_storage_[1];
  int32_t time;
  NSString *bottle;
} UsedTimeResponse_UsedTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bottle",
        .dataTypeSpecific.className = NULL,
        .number = UsedTimeResponse_UsedTime_FieldNumber_Bottle,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UsedTimeResponse_UsedTime__storage_, bottle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "time",
        .dataTypeSpecific.className = NULL,
        .number = UsedTimeResponse_UsedTime_FieldNumber_Time,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UsedTimeResponse_UsedTime__storage_, time),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UsedTimeResponse_UsedTime class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UsedTimeResponse_UsedTime__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UsedTimeResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TimePoint

@implementation TimePoint

@dynamic mode;
@dynamic value;
@dynamic endValue;

typedef struct TimePoint__storage_ {
  uint32_t _has_storage_[1];
  SrTimeMode mode;
  int32_t value;
  int32_t endValue;
} TimePoint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = SrTimeMode_EnumDescriptor,
        .number = TimePoint_FieldNumber_Mode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TimePoint__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = TimePoint_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TimePoint__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "endValue",
        .dataTypeSpecific.className = NULL,
        .number = TimePoint_FieldNumber_EndValue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TimePoint__storage_, endValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TimePoint class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TimePoint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TimePoint_Mode_RawValue(TimePoint *message) {
  GPBDescriptor *descriptor = [TimePoint descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TimePoint_FieldNumber_Mode];
  return GPBGetMessageInt32Field(message, field);
}

void SetTimePoint_Mode_RawValue(TimePoint *message, int32_t value) {
  GPBDescriptor *descriptor = [TimePoint descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TimePoint_FieldNumber_Mode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PlayRequest

@implementation PlayRequest

@dynamic hasRequest, request;
@dynamic cycleMode;
@dynamic startAtArray, startAtArray_Count;
@dynamic cycleTime;
@dynamic actionsArray, actionsArray_Count;
@dynamic traceArray, traceArray_Count;

typedef struct PlayRequest__storage_ {
  uint32_t _has_storage_[1];
  SrCycleMode cycleMode;
  int32_t cycleTime;
  BaseRequest *request;
  NSMutableArray *startAtArray;
  NSMutableArray *actionsArray;
  NSMutableArray *traceArray;
} PlayRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "request",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = PlayRequest_FieldNumber_Request,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PlayRequest__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cycleMode",
        .dataTypeSpecific.enumDescFunc = SrCycleMode_EnumDescriptor,
        .number = PlayRequest_FieldNumber_CycleMode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PlayRequest__storage_, cycleMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "startAtArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TimePoint),
        .number = PlayRequest_FieldNumber_StartAtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PlayRequest__storage_, startAtArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cycleTime",
        .dataTypeSpecific.className = NULL,
        .number = PlayRequest_FieldNumber_CycleTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PlayRequest__storage_, cycleTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "actionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayRequest_PlayAction),
        .number = PlayRequest_FieldNumber_ActionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PlayRequest__storage_, actionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "traceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PlayRequest_PlayTrace),
        .number = PlayRequest_FieldNumber_TraceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PlayRequest__storage_, traceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PlayRequest class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PlayRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PlayRequest_CycleMode_RawValue(PlayRequest *message) {
  GPBDescriptor *descriptor = [PlayRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PlayRequest_FieldNumber_CycleMode];
  return GPBGetMessageInt32Field(message, field);
}

void SetPlayRequest_CycleMode_RawValue(PlayRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [PlayRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PlayRequest_FieldNumber_CycleMode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PlayRequest_PlayAction

@implementation PlayRequest_PlayAction

@dynamic bottle;
@dynamic duration;
@dynamic power;

typedef struct PlayRequest_PlayAction__storage_ {
  uint32_t _has_storage_[1];
  int32_t duration;
  int32_t power;
  NSString *bottle;
} PlayRequest_PlayAction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bottle",
        .dataTypeSpecific.className = NULL,
        .number = PlayRequest_PlayAction_FieldNumber_Bottle,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PlayRequest_PlayAction__storage_, bottle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = PlayRequest_PlayAction_FieldNumber_Duration,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PlayRequest_PlayAction__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "power",
        .dataTypeSpecific.className = NULL,
        .number = PlayRequest_PlayAction_FieldNumber_Power,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PlayRequest_PlayAction__storage_, power),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PlayRequest_PlayAction class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PlayRequest_PlayAction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PlayRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PlayRequest_PlayTrace

@implementation PlayRequest_PlayTrace

@dynamic actionIdArray, actionIdArray_Count;
@dynamic beforeStart;
@dynamic cycleMode;
@dynamic interval;
@dynamic cycleTime;

typedef struct PlayRequest_PlayTrace__storage_ {
  uint32_t _has_storage_[1];
  int32_t beforeStart;
  SrCycleMode cycleMode;
  int32_t interval;
  int32_t cycleTime;
  GPBInt32Array *actionIdArray;
} PlayRequest_PlayTrace__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "actionIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PlayRequest_PlayTrace_FieldNumber_ActionIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PlayRequest_PlayTrace__storage_, actionIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "beforeStart",
        .dataTypeSpecific.className = NULL,
        .number = PlayRequest_PlayTrace_FieldNumber_BeforeStart,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PlayRequest_PlayTrace__storage_, beforeStart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cycleMode",
        .dataTypeSpecific.enumDescFunc = SrCycleMode_EnumDescriptor,
        .number = PlayRequest_PlayTrace_FieldNumber_CycleMode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PlayRequest_PlayTrace__storage_, cycleMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "interval",
        .dataTypeSpecific.className = NULL,
        .number = PlayRequest_PlayTrace_FieldNumber_Interval,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PlayRequest_PlayTrace__storage_, interval),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cycleTime",
        .dataTypeSpecific.className = NULL,
        .number = PlayRequest_PlayTrace_FieldNumber_CycleTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PlayRequest_PlayTrace__storage_, cycleTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PlayRequest_PlayTrace class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PlayRequest_PlayTrace__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(PlayRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PlayRequest_PlayTrace_CycleMode_RawValue(PlayRequest_PlayTrace *message) {
  GPBDescriptor *descriptor = [PlayRequest_PlayTrace descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PlayRequest_PlayTrace_FieldNumber_CycleMode];
  return GPBGetMessageInt32Field(message, field);
}

void SetPlayRequest_PlayTrace_CycleMode_RawValue(PlayRequest_PlayTrace *message, int32_t value) {
  GPBDescriptor *descriptor = [PlayRequest_PlayTrace descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PlayRequest_PlayTrace_FieldNumber_CycleMode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - StopPlayRequest

@implementation StopPlayRequest

@dynamic hasRequest, request;
@dynamic bottlesArray, bottlesArray_Count;

typedef struct StopPlayRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *request;
  NSMutableArray *bottlesArray;
} StopPlayRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "request",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = StopPlayRequest_FieldNumber_Request,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StopPlayRequest__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bottlesArray",
        .dataTypeSpecific.className = NULL,
        .number = StopPlayRequest_FieldNumber_BottlesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(StopPlayRequest__storage_, bottlesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StopPlayRequest class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StopPlayRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveTaskRequest

@implementation RemoveTaskRequest

@dynamic hasRequest, request;
@dynamic stopTasksArray, stopTasksArray_Count;

typedef struct RemoveTaskRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *request;
  NSMutableArray *stopTasksArray;
} RemoveTaskRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "request",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = RemoveTaskRequest_FieldNumber_Request,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveTaskRequest__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stopTasksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RemoveTaskRequest_RemoveTaskOption),
        .number = RemoveTaskRequest_FieldNumber_StopTasksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RemoveTaskRequest__storage_, stopTasksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveTaskRequest class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveTaskRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveTaskRequest_RemoveTaskOption

@implementation RemoveTaskRequest_RemoveTaskOption

@dynamic stopSeq;
@dynamic mode;

typedef struct RemoveTaskRequest_RemoveTaskOption__storage_ {
  uint32_t _has_storage_[1];
  int32_t stopSeq;
  SrRemoveTaskMode mode;
} RemoveTaskRequest_RemoveTaskOption__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stopSeq",
        .dataTypeSpecific.className = NULL,
        .number = RemoveTaskRequest_RemoveTaskOption_FieldNumber_StopSeq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveTaskRequest_RemoveTaskOption__storage_, stopSeq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mode",
        .dataTypeSpecific.enumDescFunc = SrRemoveTaskMode_EnumDescriptor,
        .number = RemoveTaskRequest_RemoveTaskOption_FieldNumber_Mode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemoveTaskRequest_RemoveTaskOption__storage_, mode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveTaskRequest_RemoveTaskOption class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveTaskRequest_RemoveTaskOption__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RemoveTaskRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RemoveTaskRequest_RemoveTaskOption_Mode_RawValue(RemoveTaskRequest_RemoveTaskOption *message) {
  GPBDescriptor *descriptor = [RemoveTaskRequest_RemoveTaskOption descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RemoveTaskRequest_RemoveTaskOption_FieldNumber_Mode];
  return GPBGetMessageInt32Field(message, field);
}

void SetRemoveTaskRequest_RemoveTaskOption_Mode_RawValue(RemoveTaskRequest_RemoveTaskOption *message, int32_t value) {
  GPBDescriptor *descriptor = [RemoveTaskRequest_RemoveTaskOption descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RemoveTaskRequest_RemoveTaskOption_FieldNumber_Mode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - DevAttrOption

@implementation DevAttrOption

@dynamic attr;
@dynamic value;

typedef struct DevAttrOption__storage_ {
  uint32_t _has_storage_[1];
  SrDevAttrType attr;
  NSString *value;
} DevAttrOption__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "attr",
        .dataTypeSpecific.enumDescFunc = SrDevAttrType_EnumDescriptor,
        .number = DevAttrOption_FieldNumber_Attr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevAttrOption__storage_, attr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = DevAttrOption_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DevAttrOption__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevAttrOption class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevAttrOption__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DevAttrOption_Attr_RawValue(DevAttrOption *message) {
  GPBDescriptor *descriptor = [DevAttrOption descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DevAttrOption_FieldNumber_Attr];
  return GPBGetMessageInt32Field(message, field);
}

void SetDevAttrOption_Attr_RawValue(DevAttrOption *message, int32_t value) {
  GPBDescriptor *descriptor = [DevAttrOption descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DevAttrOption_FieldNumber_Attr];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GetDevAttrsRequest

@implementation GetDevAttrsRequest

@dynamic hasRequest, request;
@dynamic attrsArray, attrsArray_Count;

typedef struct GetDevAttrsRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *request;
  GPBEnumArray *attrsArray;
} GetDevAttrsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "request",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetDevAttrsRequest_FieldNumber_Request,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDevAttrsRequest__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attrsArray",
        .dataTypeSpecific.enumDescFunc = SrDevAttrType_EnumDescriptor,
        .number = GetDevAttrsRequest_FieldNumber_AttrsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDevAttrsRequest__storage_, attrsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDevAttrsRequest class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDevAttrsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDevAttrsResponse

@implementation GetDevAttrsResponse

@dynamic hasResponse, response;
@dynamic attrsArray, attrsArray_Count;

typedef struct GetDevAttrsResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *response;
  NSMutableArray *attrsArray;
} GetDevAttrsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "response",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetDevAttrsResponse_FieldNumber_Response,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDevAttrsResponse__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attrsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DevAttrOption),
        .number = GetDevAttrsResponse_FieldNumber_AttrsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetDevAttrsResponse__storage_, attrsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDevAttrsResponse class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDevAttrsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetDevAttrsRequest

@implementation SetDevAttrsRequest

@dynamic hasRequest, request;
@dynamic attrsArray, attrsArray_Count;

typedef struct SetDevAttrsRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *request;
  NSMutableArray *attrsArray;
} SetDevAttrsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "request",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = SetDevAttrsRequest_FieldNumber_Request,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetDevAttrsRequest__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "attrsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DevAttrOption),
        .number = SetDevAttrsRequest_FieldNumber_AttrsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SetDevAttrsRequest__storage_, attrsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetDevAttrsRequest class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetDevAttrsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceModelResponse

@implementation DeviceModelResponse

@dynamic hasResponse, response;
@dynamic supportCmdsArray, supportCmdsArray_Count;
@dynamic controlsArray, controlsArray_Count;

typedef struct DeviceModelResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *response;
  GPBEnumArray *supportCmdsArray;
  NSMutableArray *controlsArray;
} DeviceModelResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "response",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = DeviceModelResponse_FieldNumber_Response,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceModelResponse__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "supportCmdsArray",
        .dataTypeSpecific.enumDescFunc = SrCmdId_EnumDescriptor,
        .number = DeviceModelResponse_FieldNumber_SupportCmdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeviceModelResponse__storage_, supportCmdsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "controlsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(AppControlSet),
        .number = DeviceModelResponse_FieldNumber_ControlsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeviceModelResponse__storage_, controlsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceModelResponse class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceModelResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppControlSet

@implementation AppControlSet

@dynamic controllerOneOfCase;
@dynamic identity;
@dynamic name;
@dynamic switch_p;
@dynamic slider;
@dynamic spin;
@dynamic switchSlider;

typedef struct AppControlSet__storage_ {
  uint32_t _has_storage_[2];
  int32_t identity;
  NSString *name;
  AppControlSwitch *switch_p;
  AppControlSlider *slider;
  AppControlSpin *spin;
  AppControlSwitchSlider *switchSlider;
} AppControlSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identity",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSet_FieldNumber_Identity,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppControlSet__storage_, identity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSet_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppControlSet__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "switch_p",
        .dataTypeSpecific.className = GPBStringifySymbol(AppControlSwitch),
        .number = AppControlSet_FieldNumber_Switch_p,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AppControlSet__storage_, switch_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "slider",
        .dataTypeSpecific.className = GPBStringifySymbol(AppControlSlider),
        .number = AppControlSet_FieldNumber_Slider,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AppControlSet__storage_, slider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "spin",
        .dataTypeSpecific.className = GPBStringifySymbol(AppControlSpin),
        .number = AppControlSet_FieldNumber_Spin,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AppControlSet__storage_, spin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "switchSlider",
        .dataTypeSpecific.className = GPBStringifySymbol(AppControlSwitchSlider),
        .number = AppControlSet_FieldNumber_SwitchSlider,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(AppControlSet__storage_, switchSlider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppControlSet class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppControlSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "controller",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void AppControlSet_ClearControllerOneOfCase(AppControlSet *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - AppControlSwitch

@implementation AppControlSwitch

@dynamic status;

typedef struct AppControlSwitch__storage_ {
  uint32_t _has_storage_[1];
  SrSwitchStatus status;
} AppControlSwitch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = SrSwitchStatus_EnumDescriptor,
        .number = AppControlSwitch_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppControlSwitch__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppControlSwitch class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppControlSwitch__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AppControlSwitch_Status_RawValue(AppControlSwitch *message) {
  GPBDescriptor *descriptor = [AppControlSwitch descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AppControlSwitch_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetAppControlSwitch_Status_RawValue(AppControlSwitch *message, int32_t value) {
  GPBDescriptor *descriptor = [AppControlSwitch descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AppControlSwitch_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - AppControlSlider

@implementation AppControlSlider

@dynamic min;
@dynamic max;
@dynamic step;
@dynamic value;

typedef struct AppControlSlider__storage_ {
  uint32_t _has_storage_[1];
  int32_t min;
  int32_t max;
  int32_t step;
  int32_t value;
} AppControlSlider__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "min",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSlider_FieldNumber_Min,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppControlSlider__storage_, min),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "max",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSlider_FieldNumber_Max,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppControlSlider__storage_, max),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "step",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSlider_FieldNumber_Step,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppControlSlider__storage_, step),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSlider_FieldNumber_Value,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AppControlSlider__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppControlSlider class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppControlSlider__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\203\000\002\203\000\003\204\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppControlSpin

@implementation AppControlSpin

@dynamic step;
@dynamic angle;
@dynamic angularSpeed;

typedef struct AppControlSpin__storage_ {
  uint32_t _has_storage_[1];
  int32_t step;
  int32_t angle;
  int32_t angularSpeed;
} AppControlSpin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "step",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSpin_FieldNumber_Step,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppControlSpin__storage_, step),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "angle",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSpin_FieldNumber_Angle,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppControlSpin__storage_, angle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "angularSpeed",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSpin_FieldNumber_AngularSpeed,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppControlSpin__storage_, angularSpeed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppControlSpin class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppControlSpin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\204\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AppControlSwitchSlider

@implementation AppControlSwitchSlider

@dynamic status;
@dynamic min;
@dynamic max;
@dynamic step;
@dynamic value;

typedef struct AppControlSwitchSlider__storage_ {
  uint32_t _has_storage_[1];
  SrSwitchStatus status;
  int32_t min;
  int32_t max;
  int32_t step;
  int32_t value;
} AppControlSwitchSlider__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = SrSwitchStatus_EnumDescriptor,
        .number = AppControlSwitchSlider_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AppControlSwitchSlider__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "min",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSwitchSlider_FieldNumber_Min,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AppControlSwitchSlider__storage_, min),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "max",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSwitchSlider_FieldNumber_Max,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AppControlSwitchSlider__storage_, max),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "step",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSwitchSlider_FieldNumber_Step,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AppControlSwitchSlider__storage_, step),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = AppControlSwitchSlider_FieldNumber_Value,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AppControlSwitchSlider__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AppControlSwitchSlider class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AppControlSwitchSlider__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\203\000\003\203\000\004\204\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AppControlSwitchSlider_Status_RawValue(AppControlSwitchSlider *message) {
  GPBDescriptor *descriptor = [AppControlSwitchSlider descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AppControlSwitchSlider_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetAppControlSwitchSlider_Status_RawValue(AppControlSwitchSlider *message, int32_t value) {
  GPBDescriptor *descriptor = [AppControlSwitchSlider descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AppControlSwitchSlider_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SetControlAttrRequest

@implementation SetControlAttrRequest

@dynamic hasRequest, request;
@dynamic settingsArray, settingsArray_Count;

typedef struct SetControlAttrRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *request;
  NSMutableArray *settingsArray;
} SetControlAttrRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "request",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = SetControlAttrRequest_FieldNumber_Request,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetControlAttrRequest__storage_, request),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "settingsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SetControlAttrRequest_SetControlAttr),
        .number = SetControlAttrRequest_FieldNumber_SettingsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SetControlAttrRequest__storage_, settingsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetControlAttrRequest class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetControlAttrRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetControlAttrRequest_SetControlAttr

@implementation SetControlAttrRequest_SetControlAttr

@dynamic identity;
@dynamic attr;
@dynamic value;

typedef struct SetControlAttrRequest_SetControlAttr__storage_ {
  uint32_t _has_storage_[1];
  int32_t identity;
  NSString *attr;
  NSString *value;
} SetControlAttrRequest_SetControlAttr__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "identity",
        .dataTypeSpecific.className = NULL,
        .number = SetControlAttrRequest_SetControlAttr_FieldNumber_Identity,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetControlAttrRequest_SetControlAttr__storage_, identity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "attr",
        .dataTypeSpecific.className = NULL,
        .number = SetControlAttrRequest_SetControlAttr_FieldNumber_Attr,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetControlAttrRequest_SetControlAttr__storage_, attr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = SetControlAttrRequest_SetControlAttr_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SetControlAttrRequest_SetControlAttr__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetControlAttrRequest_SetControlAttr class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetControlAttrRequest_SetControlAttr__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SetControlAttrRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DevWifiListResponse

@implementation DevWifiListResponse

@dynamic hasResponse, response;
@dynamic wifissidListArray, wifissidListArray_Count;

typedef struct DevWifiListResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *response;
  NSMutableArray *wifissidListArray;
} DevWifiListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "response",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = DevWifiListResponse_FieldNumber_Response,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DevWifiListResponse__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wifissidListArray",
        .dataTypeSpecific.className = NULL,
        .number = DevWifiListResponse_FieldNumber_WifissidListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DevWifiListResponse__storage_, wifissidListArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DevWifiListResponse class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DevWifiListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetDevWifiRequest

@implementation SetDevWifiRequest

@dynamic wifissid;
@dynamic wifipwd;

typedef struct SetDevWifiRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *wifissid;
  NSString *wifipwd;
} SetDevWifiRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wifissid",
        .dataTypeSpecific.className = NULL,
        .number = SetDevWifiRequest_FieldNumber_Wifissid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetDevWifiRequest__storage_, wifissid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wifipwd",
        .dataTypeSpecific.className = NULL,
        .number = SetDevWifiRequest_FieldNumber_Wifipwd,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetDevWifiRequest__storage_, wifipwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetDevWifiRequest class]
                                     rootClass:[ScentrealmRoot class]
                                          file:ScentrealmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetDevWifiRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
